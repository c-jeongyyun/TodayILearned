## 오늘 배운 것 
1. 배열에서 중복 제거하기👥   
  
    배열에서 중복을 제거하는 방법에는 여러가지가 있다.   
  그 중, 이 방법은 처음 알게 되어 정리해본다.   
    ``` js
    items.filter((item,index) => items.indexOf(item) === index) 
    ```
    indexOf는 배열에서 같은 값을 가지는 요소 중 가장 첫번째 것의 인덱스를 반환한다. 
    만약 이게 현재 인덱스와 동일하다면 처음 나오는 요소인 것이고,   
    현재 인덱스와 동일하지 않다면, 같은 요소가 여러개여서 `indexOf가 반환한 인덱스` < `현재 인덱스`가 되어 filter 함수에 의해 걸러지게 된다.
    
    나는 오브젝트들이 들어있는 배열에서 중복을 제거하고 싶었기 때문에,   
    `===`연산자를 사용했을 때 같은 것을 찾는 `indexOf` 함수가 아닌, `findIndex` 함수를 사용하여 같은 요소를 판단해내는 기준을 custom 하였다. 
    
    ``` js
    items.filter((item, idx) => items.findIndex((i) => i.label === item.label) === idx)
    ```
    내 경우에는 라벨이 같으면 같은 오브젝트라고 판단할 수 있었기에 위와 같이 작성하였다.
    
    이 방식의 O(n^2)으로 그다지 효율적인 방법은 아니다. 
    배열의 크기가 작을 때 활용하면 좋을 방식! 
    
    🔗 참고 : https://hianna.tistory.com/422
    
    
    <br/>
    
    

## Trouble Shooting 🔫
1. `set~~ 함수`가 자식의 `useEffect` 안에서 부모에서 사용될 때 👨‍👩‍👦   

   여기서 `set~~ 함수`는 `useState`에서 반환한 함수를 의미한다.
   나는 필터 구현 중이었고, 필터항목을 저장하는 `filterItems`를 `state`로 선언하여 부모 컴포넌트와 자식 컴포넌트 모두에서 사용중이었다. 
   이때, 자식 컴포넌트의 `useEffect`내부에서 `setFilterItems` 함수를 이용하는 구문이 존재했다. 
   
   처음에는 `setFilterItems`를 자식 컴포넌트에서만 사용했지만, 기능상 부모 컴포넌트에서도 사용하게 되었다. 
   
   그런데 웬걸.... 부모 컴포넌트에서 `setFilterItems`를 이용해 `state`를 업데이트해도, 변경이 되지 안고 자꾸 원하지 않는 상태가 되는 것이었다....
   
   그 원인은 자식 컴포넌트의 `useEffect` 내부에 있는 `setFilterItems` 때문.... 
   내가 구현하고 있는 자식 컴포넌트의 특성상 지워졌다가 다시 렌더링되는 구문이 있었고, 그 때마다 `useEffect` 내부 구문이 다시 실행되어서 자꾸 원하지 않는 상태로 변경되어버렸던 것. 
   
   **자식 컴포넌트가 지워졌다가 다시 렌더링되어야 하는 것 && 이 시기가 부모에서 `setFilterItems`로 뭔가를 다시 설정해야하는 시점이었다는 것** 이 맞물리면서 절망의 로직이 시작되었던 것이다...  
   상황에 따라 다르긴 하겠지만... `set~~ 함수`를 자식과 부모 모두가 사용할 때는, 웬만하면  자식 컴포넌트의 `useEffect`에서는 `set~~ 함수`를 사용하지 말자....  
   
    > 요약: 로직 설계를 잘하자....
   
   
   
   
